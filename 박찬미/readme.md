<details>
  <summary><h3 style="display: inline; margin-left: 5px;">2025.1.13.</h3></summary>
  <div markdown="1">
    <br>
    컨설턴트님, 코치님들과 팀 미팅을 진행 결과, 우리 프로젝트에서 구급대원의 화면은 하이브리드 앱 혹은 PWA를 활용하는 게 좋을 것 같다는 의견을 받아 해당 내용을 검색해보았다.<br>
    <h3>하이브리드앱과 PWA</h3>
    <ul>
      <li>하이브리드앱
        <p>웹 기술(HTML, CSS, JavaScript)로 개발된 웹앱을 모바일 앱 형태로 래핑하는 방식으로 만들어진 애플리케이션이다. 앱 스토어를 통해 배포되며, 사용자가 직접 설치해야 한다.</p>
      </li>
      <li>PWA (Progressive Web App)
        <p>웹앱의 한 형태로, 모바일 기기에서 앱과 유사한 사용자 경험을 제공하는 웹앱이다. 웹앱과 달리 앱 스토어를 통해 설치할 필요가 없으며, 웹 브라우저를 통해 URL로 접근하여 쉽게 사용할 수 있다.</p>
      </li>
      <li>정리
        <p>PWA는 웹 기반으로 개발되어 빠른 로딩과 쉬운 접근성을 제공하지만, 기기 기능 접근에 제한이 있다다. 반면 하이브리드 앱은 네이티브 기능을 더 많이 활용할 수 있지만, 개발 및 유지보수 비용이 더 높을 수 있다. 프로젝트의 요구사항과 목표에 따라 적절한 방식을 선택해야 한다.<br>
        우리 프로젝트는 기본적으로 웹 기술을 활용한 프로젝트이기 때문에에 PWA를 적용하는 게 좋을 것 같다.</p>
      </li>
    </ul>
  </div>
</details>

<br>

<details>
  <summary><h3 style="display: inline; margin-left: 5px;">2025.1.14.</h3></summary>
  <div markdown="1">
    <br>
    <h3>ERD</h3>
    <p>ERD는 데이터베이스의 구조를 시각적으로 표현하는 도구이다. ERD를 통해 데이터와 그 관계를 파악하고, 데이터베이스 설계 시 발생할 수 있는 문제점을 미리 찾아낼 수 있다.</p><br>
    <strong>점선과 실선</strong>
      <p>실선은 식별 관계를 나타낸다. 부모 테이블의 pk가 자식 테이블의 pk의 일부가 되는 경우, 부모 엔티티가 존재해야 자식 엔티티가 존재할 수 있는 강한 종속 관계, 자식 테이블의 기본키에 부모 테이블의 기본키가 포함되는 경우에 실선을 사용한다.<br>
      점선은 비식별 관계를 나타낸다. 부모 테이블의 pk가 자식 테이블의 일반 속성으로 사용되는 경우, 부모 엔티티 없이도 자식 엔티티가 독립적으로 존재할 수 있는 약한 종속 관계, 자식 테이블의 기본키에 부모 테이블의 기본키가 포함되지 않는 경우에 점선을 사용한다.</p>
    <strong>ERD 만들 때 고려할 점</strong>
      <ol>
        <li>필드명은 정확하게 (한 눈에 알아보기 쉽게)</li>
        <li>1:1 관계일 때, 꼭 테이블을 나눌 필요가 있는지 고민해보기</li>
        <li>기능이 있다고 무작정 필드를 추가하지 말고 해당 데이터를 저장할 필요가 있는지, 어떻게 활용할건지 고민해보기</li>
      </ol>
  </div>
</details>

<br>

<details>
  <summary><h3 style="display: inline; margin-left: 5px;">2025.1.15.</h3></summary>
  <div markdown="1">
    <br>
    <h3>DB - Index</h3>
    <strong>Index</strong>
    <p>인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다.</p><br>
    <strong>Clustered Index</strong>
    <ul>
      <li>클러스터 인덱스는 테이블의 데이터 자체가 인덱스 구조에 맞게 정렬되어 저장된다.</li>
      <li>클러스터드 인덱스를 생성하면 데이터 행들이 인덱스 키 값에 따라 정렬된다.</li>
      <li>테이블당 하나의 클러스터 인덱스만 만들 수 있다.</li>
      <li>정렬이 되어 있다는 전제조건이 있기 때문에 검색시 성능이 매우 빠르다.</li>
      <li>하지만 전제조건을 지키기 위해 삽입, 수정, 삭제를 할 때는 성능이 아쉬울 수 있다.</li>
    </ul>
    <strong>None-Clustered Index</strong>
    <ul>
    <li>비클러스터 인덱스는 인덱스 키 값과 해당 데이터 행의 위치를 포함하는 포인터를 저장한다.</li>
    <li>하나의 테이블에 여러 개의 비클러스터 인덱스를 생성할 수 있다.</li>
    <li>비클러스터 인덱스가 생성되면 별도의 페이지에서 인덱스를 구성하기 때문에 추가적인 용량이 필요하다.</li>
    <li>클러스터 인덱스에 비해 검색은 느리지만 삽입, 수정, 삭제는 빠르다.</li>
    </ul>
  </div>
</details>